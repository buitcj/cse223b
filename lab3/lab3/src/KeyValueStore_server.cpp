// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

/*
TODO:

-impl put
    -call putphase1 on all the servers
    -on ack of putphase1 on all servers, call putphase2 on all servers
-impl putphase1
    -store key/value in the commit queue
-impl putphase2
    -commit the key/value
-impl commit queue - separate thread?  

*/

#include "KeyValueStore.h"
#include <algorithm>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

// JULIAN ADDED***
#include <transport/TSocket.h>

#define JSON_IS_AMALGAMATION
#include <json/json.h>
// END JULIAN ADDED***

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace std;

using namespace  ::KeyValueStore;

class KeyValueStoreHandler : virtual public KeyValueStoreIf {
 public:
  string SET_PREFIX;
  string TIMESTAMPS;
  string HOST_IDS;

  void vectorTimestampToJson(std::vector<int>& vec, Json::Value& root)
  {
    root = Json::Value(Json::arrayValue);
    for(unsigned int i = 0; i < vec.size(); i++)
    {
        root.append(Json::Value(vec.at(i)));
    }
  }

  KeyValueStoreHandler(int argc, char** argv) {
    // Your initialization goes here
    _initialized = false;
    SET_PREFIX = "set_";
    TIMESTAMPS = "timestamps";
    HOST_IDS = "hostids";
    
    _id = atoi(argv[1]);

    for(int i = 3; i+1 < argc; i += 2) {
      string peer_ip(argv[i]);
      int peer_port = atoi(argv[i+1]);
      _backendServerVector.push_back(make_pair(peer_ip, peer_port));
      cout << "Backend server at: " << peer_ip << " on port: " << peer_port << endl;
    }

    _origNumServers = (int) _backendServerVector.size() + 1; // + 1 for myself

    cout << "original num servers: " << _origNumServers << endl;
    for(int i = 0; i < _origNumServers; i++)
    {
        _myVectorTimestamp.push_back(0);
    }

    // ATTEMPT TO SYNC WITH ONE OF THE OTHER SERVERS
    for(unsigned int i = 0; i < _backendServerVector.size(); i++)
    {
        cout << "trying to sync" << endl;
        bool synced = sync(_backendServerVector[i].first, _backendServerVector[i].second);
        if(synced)
        {
            cout << "successfully synced" << endl;
            break;
        }
    }

    // if we got here, we either successfully sync-ed OR there was not a single server to sync with so we are starting from scratch, in either case we are ready to begin
    _initialized = true;
    cout << "Ready to begin" << endl;
  }

  void Get(GetResponse& _return, const std::string& key) {
    cout << "Get called on key: " << key << endl;
    map<string, string>::iterator iter;
    if((iter = _kvs.find(key)) == _kvs.end())
    {
        // was not found
        _return.status = KVStoreStatus::EKEYNOTFOUND;
        return;
    } 

    _return.status = KVStoreStatus::OK;
    _return.value = iter->second;
    cout << "Get found: " << _return.value << endl;
    return;
  }

  KVStoreStatus::type Put(const std::string& key, const std::string& value, const std::string& clientid) {
    // call PutPhase1Internal on all the other backend servers
    // if any of them return a failure, keep moving, but remove that server from the list 
    // call PutPhase2Internal on all the backend servers
    // return ok if there are still servers

    cout << "Put called for key: " << key << endl;

    incClock();

    string new_value = value;

    printf("\tEntering phase1\n");

    // INSERT THE TIMESTAMP
    // only if it's a set we want to insert the timestamp
    if((int) key.length() > 4 && key.substr(0, 4).compare(SET_PREFIX) == 0)
    {
        Json::Value tribble_set;
        Json::Reader reader;
        bool parse_ret_val = reader.parse(value, tribble_set);
        if(parse_ret_val == false)
        {
            return KVStoreStatus::INTERNAL_FAILURE;
        }

        Json::Value json_ts;
        vectorTimestampToJson(_myVectorTimestamp, json_ts);        

        tribble_set[TIMESTAMPS].append(json_ts);
        tribble_set[HOST_IDS].append(_id);

        Json::StyledWriter writer;
        new_value = writer.write(tribble_set);
    }

    printf("\tEntering phase1\n");

    // PHASE 1 ===========================
    vector<pair<string, int> >::iterator iter = _backendServerVector.begin();
    while(iter != _backendServerVector.end())
    {
        try {
            boost::shared_ptr<TSocket> socket(new TSocket(iter->first, iter->second));
            boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            KeyValueStoreClient client(protocol);
            transport->open();
            string out_clientid("tribbleserver");
            KVStoreStatus::type put_st = client.PutPhase1Internal(key, new_value, out_clientid, _myVectorTimestamp);
            transport->close();

            if(put_st != KVStoreStatus::OK)
            {
                // SHOULD NEVER HAPPEN**********************
                // iter = _backendServerVector.erase(iter);
                return KVStoreStatus::INTERNAL_FAILURE;
            }
            else
            {
                iter++;
            }
        }
        catch (TTransportException t)
        {
            // this server failed 
            iter = _backendServerVector.erase(iter);
        }
    } 

    printf("\tEntering phase2\n");

    // PHASE 2 =================
    iter = _backendServerVector.begin();
    while(iter != _backendServerVector.end())
    {
        boost::shared_ptr<TSocket> socket(new TSocket(iter->first, iter->second));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        KeyValueStoreClient client(protocol);
        try {
            transport->open();
            string out_clientid("tribbleserver");
            KVStoreStatus::type put_st = client.PutPhase2Internal(key, true, out_clientid);
            transport->close();

            if(put_st != KVStoreStatus::OK)
            {
                // SHOULD NEVER HAPPEN**********************
                // iter = _backendServerVector.erase(iter);
                return KVStoreStatus::INTERNAL_FAILURE;
            }
            else
            {
                iter++;
            }
        }
        catch (TTransportException t)
        {
            // this server failed 
            iter = _backendServerVector.erase(iter);
        }
    } 

    printf("\tDone with phase2\n");

    /*
    We probably never care if the KVS doesn't have any peers - it'll always have itself (forever alone)
    
    // at this point, _backendServerVector size will have been reduced because if any servers died.  
    if(_backendServerVector.size() == 0)
    {   
        printf("Failure: No more KVS peers\n");
        return KVStoreStatus::INTERNAL_FAILURE;
    }
    */

    _kvs[key] = new_value;

    cout << "Put placed: " << new_value << endl;

    return KVStoreStatus::OK;
  }

  KVStoreStatus::type PutPhase1Internal(const std::string& key, const std::string& value, const std::string& clientid, const std::vector<int32_t>& vec_timestamp) {
    printf("PutPhase1Internal\n");

    incClock();
    updateMyVectorTimestamp(vec_timestamp);

    //  just stick the key/value into the commit buffer
    pair<string, string> put_op(key, value);
    _uncommittedBuffer.push_back(put_op);
    return KVStoreStatus::OK;
  }

  KVStoreStatus::type PutPhase2Internal(const std::string& key, const bool commit, const std::string& clientid) {
    printf("PutPhase2Internal\n");

    incClock();
    
    // SHOULD PROBABLY HAVE A GUID FOR MULTIPLE PUTS TO THE SAME KEY ********************
    list<pair<string, string> >::iterator iter = _uncommittedBuffer.begin();
    while(iter != _uncommittedBuffer.end())
    {
        if(iter->first.compare(key) == 0)
        {
            _kvs[key] = iter->second;
            _uncommittedBuffer.erase(iter);
            return KVStoreStatus::OK;
        }
        else
        {
            iter++;
        }
    }

    return KVStoreStatus::EKEYNOTFOUND;
  }

  void Sync(SyncResponse& _return) {
    // Your implementation goes here
    printf("Sync\n");

    if(_initialized == true)
    {
        _return.kvs = _kvs;
        _return.status = KVStoreStatus::OK;
    }
    else
        _return.status = KVStoreStatus::INTERNAL_FAILURE;
  }

  bool sync(string server, int port)
  {
    // Making the RPC Call to the kv server
    cout << "In the sync method" << endl;
    try
    {
        boost::shared_ptr<TSocket> socket(new TSocket(server, port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        KeyValueStoreClient client(protocol);
        transport->open();
        SyncResponse response;
        client.Sync(response);
        transport->close();

        // NEED TO CATCH EXCEPTIONS!?!??!?!?!?!?!?!??!?!?!?!?!??!?!?!?!?!?!?!?!?

        if(response.status == KVStoreStatus::OK)
        {
            _kvs = response.kvs;
            _initialized = true;
            return true;
        }
        else
        {
            cout << "server responded with a non OK msg" << endl;
            return false;
        }
    }
    catch (...)
    {
        cout << "Caught an exception in sync" << endl;
        return false;
    }
  }

  bool IsAlive() {
    // Your implementation goes here
    printf("isAlive\n");
    return true;
  }

  bool isAlive(string server, int port)
  {
    // Making the RPC Call to the kv server
    boost::shared_ptr<TSocket> socket(new TSocket(server, port));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    KeyValueStoreClient client(protocol);
    transport->open();
    bool is_alive = client.IsAlive();
    transport->close();

    // NEED TO CATCH EXCEPTIONS!?!??!?!?!?!?!?!??!?!?!?!?!??!?!?!?!?!?!?!?!?

    return is_alive;
  }

  void incClock()
  {
    _myVectorTimestamp[_id] = _myVectorTimestamp[_id] + 1;
  }

  void updateMyVectorTimestamp(const vector<int32_t>& ts)
  {
    for(unsigned int i = 0; i < ts.size(); i++)
    {
        _myVectorTimestamp[i] = max(ts[i], _myVectorTimestamp[i]); 
    }
  }

  private:
    int _id;
    vector < pair<string, int> > _backendServerVector;
    int _origNumServers;
    vector<int> _myVectorTimestamp;
    map<string, string> _kvs;
    bool _initialized;

    list<pair<string, string> > _uncommittedBuffer;
};

int main(int argc, char **argv) {
  if((argc < 3) || !(argc % 2)) {
      cerr << "Usage: " << argv[0] << " id localport peer1 port1..." << endl;
      exit(1);
  }
  int port = atoi(argv[2]);
  shared_ptr<KeyValueStoreHandler> handler(new KeyValueStoreHandler(argc, argv));
  shared_ptr<TProcessor> processor(new KeyValueStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

