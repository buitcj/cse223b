// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

/*
TODO:

-impl put
    -call putphase1 on all the servers
    -on ack of putphase1 on all servers, call putphase2 on all servers
-impl putphase1
    -store key/value in the commit queue
-impl putphase2
    -commit the key/value
-impl commit queue - separate thread?  

*/

#include "KeyValueStore.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

// JULIAN ADDED***
#include <transport/TSocket.h>
// END JULIAN ADDED***

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace std;

using namespace  ::KeyValueStore;

class KeyValueStoreHandler : virtual public KeyValueStoreIf {
 public:
  string SET_PREFIX;

  KeyValueStoreHandler(int argc, char** argv) {
    // Your initialization goes here
    _initialized = false;
    SET_PREFIX = "set_";

    _id = atoi(argv[1]);
    int index = 0;

    for(int i = 3; i+1 < argc; i += 2) {
      if (index == _id) {
        _backendServerVector.push_back(make_pair("localhost", atoi(argv[2])));
      }
      string peer_ip(argv[i]);
      int peer_port = atoi(argv[i+1]);
      _backendServerVector.push_back(make_pair(peer_ip, peer_port));
      cout << "Backend server at: " << peer_ip << " on port: " << peer_port << endl;
    }

    // ATTEMPT TO SYNC WITH ONE OF THE OTHER SERVERS
  }

  void Get(GetResponse& _return, const std::string& key) {
    printf("Get\n");
    map<string, string>::iterator iter;
    if((iter = _kvs.find(key)) == _kvs.end())
    {
        // was not found
        _return.status = KVStoreStatus::EKEYNOTFOUND;
        return;
    } 

    _return.status = KVStoreStatus::OK;
    _return.value = iter->second;
    return;
  }

  KVStoreStatus::type Put(const std::string& key, const std::string& value, const std::string& clientid) {
    // call PutPhase1Internal on all the other backend servers
    // if any of them return a failure, keep moving, but remove that server from the list 
    // call PutPhase2Internal on all the backend servers
    // return ok if there are still servers

    printf("Put\n");


    // PHASE 1 ===========================
    vector<pair<string, int> >::iterator iter = _backendServerVector.begin();
    while(iter != _backendServerVector.end())
    {
        boost::shared_ptr<TSocket> socket(new TSocket(iter->first, iter->second));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        KeyValueStoreClient client(protocol);
        try {
            transport->open();
            string out_clientid("tribbleserver");
            KVStoreStatus::type put_st = client.PutPhase1Internal(key, value, out_clientid);
            transport->close();

            if(put_st != KVStoreStatus::OK)
            {
                // SHOULD NEVER HAPPEN**********************
                // iter = _backendServerVector.erase(iter);
                return KVStoreStatus::INTERNAL_FAILURE;
            }
            else
            {
                iter++;
            }
        }
        catch (TTransportException t)
        {
            // this server failed 
            iter = _backendServerVector.erase(iter);
        }
    } 

    // PHASE 2 =================
    iter = _backendServerVector.begin();
    while(iter != _backendServerVector.end())
    {
        boost::shared_ptr<TSocket> socket(new TSocket(iter->first, iter->second));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        KeyValueStoreClient client(protocol);
        try {
            transport->open();
            string out_clientid("tribbleserver");
            KVStoreStatus::type put_st = client.PutPhase2Internal(key, true, out_clientid);
            transport->close();

            if(put_st != KVStoreStatus::OK)
            {
                // SHOULD NEVER HAPPEN**********************
                // iter = _backendServerVector.erase(iter);
                return KVStoreStatus::INTERNAL_FAILURE;
            }
            else
            {
                iter++;
            }
        }
        catch (TTransportException t)
        {
            // this server failed 
            iter = _backendServerVector.erase(iter);
        }
    } 

    // at this point, _backendServerVector size will have been reduced because if any servers died.  
    if(_backendServerVector.size() == 0)
    {   
        return KVStoreStatus::INTERNAL_FAILURE;
    }

    return KVStoreStatus::OK;
  }

  KVStoreStatus::type PutPhase1Internal(const std::string& key, const std::string& value, const std::string& clientid) {
    //  just stick the key/value into the commit buffer
    pair<string, string> put_op(key, value);
    _uncommittedBuffer.push_back(put_op);
    return KVStoreStatus::OK;
  }

  KVStoreStatus::type PutPhase2Internal(const std::string& key, const bool commit, const std::string& clientid) {
    printf("PutPhase2Internal\n");
    
    // SHOULD PROBABLY HAVE A GUID FOR MULTIPLE PUTS TO THE SAME KEY ********************
    list<pair<string, string> >::iterator iter = _uncommittedBuffer.begin();
    while(iter != _uncommittedBuffer.end())
    {
        if(iter->first.compare(key) == 0)
        {
            _kvs[key] = iter->second;
            _uncommittedBuffer.erase(iter);
            return KVStoreStatus::OK;
        }
        else
        {
            iter++;
        }
    }

    return KVStoreStatus::EKEYNOTFOUND;
  }

  void Sync(SyncResponse& _return) {
    // Your implementation goes here
    printf("Sync\n");

    _return.kvs = _kvs;
    _return.status = KVStoreStatus::OK;
  }

  private:
    int _id;
    vector < pair<string, int> > _backendServerVector;
    map<string, string> _kvs;
    bool _initialized;

    list<pair<string, string> > _uncommittedBuffer;
};

int main(int argc, char **argv) {
  if((argc < 3) || !(argc % 2)) {
      cerr << "Usage: " << argv[0] << " id localport peer1 port1..." << endl;
      exit(1);
  }
  int port = atoi(argv[2]);
  shared_ptr<KeyValueStoreHandler> handler(new KeyValueStoreHandler(argc, argv));
  shared_ptr<TProcessor> processor(new KeyValueStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

