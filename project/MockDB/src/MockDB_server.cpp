// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MockDB.h"
#include "GeoPoint.h"
#include <stdlib.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::MockDBServer;

using namespace std;

class MockDBHandler : virtual public MockDBIf {
 public:
  MockDBHandler() {
    // Your initialization goes here
    _is_db = true;

    _id = -1;
    _db_hostname = NULL;
    _db_port = -1;
  }

  MockDBHandler(int id, char* db_hostname, int db_port)
  {
    _id = id;
    _db_hostname = db_hostname;
    _db_port = db_port;

    _is_db = false;
  }

  void GetPointsInRegion(GetPointsResponse& _return, const ThriftGeoPoint& ll, const ThriftGeoPoint& ur) {
    printf("GetPointsInRegion\n");
    GeoPoint lower_pt(ll.xCoord, -90.0);
    multiset<GeoPoint>::iterator lower_iter = _pts.lower_bound(lower_pt);
    if(lower_iter != _pts.end())
    {
        while(lower_iter != _pts.end() && lower_iter->xCoord <= ur.xCoord)
        {
            if(lower_iter->yCoord >= ll.yCoord &&
               lower_iter->yCoord <= ur.yCoord)
            {
                ThriftGeoPoint gpt;
                gpt.xCoord = lower_iter->xCoord;
                gpt.yCoord = lower_iter->yCoord;
                _return.pts.push_back(gpt);
            }
            lower_iter++;
        }
        _return.status = ServerStatus::OK;
    }
    else
    {
        _return.status = ServerStatus::OK;
        _return.pts.clear();
    }
  }

  ServerStatus::type AddPoint(const ThriftGeoPoint& p) {
    cout << "AddPoint called: (" << p.xCoord << "," << p.yCoord << ")" << endl;
    GeoPoint pt(p.xCoord, p.yCoord);
    _pts.insert(pt);

    if(_is_db == false)
    {
        // connect to the db and add the pt 
        string s_db_hostname(_db_hostname);
        boost::shared_ptr<TSocket> socket(new TSocket(s_db_hostname, _db_port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        MockDBClient mock_client(protocol);
        // Making the RPC Call
        transport->open();
        ServerStatus::type status = mock_client.AddPoint(p);
        transport->close();
        return status;
    }

    return ServerStatus::OK;
  }

  double GetEndXCoordinate(const double start_x_coord, const int32_t num_points) {
    const double DELTA = 0.0000003;
    printf("GetEndXCoordinate\n");
    multiset<GeoPoint>::iterator iter;
    GeoPoint pt(start_x_coord, -90.0);
    iter = _pts.find(pt);
    multiset<GeoPoint>::iterator prev_iter;
    int counter = 0;
    while(iter != _pts.end() && counter < num_points)
    {
        prev_iter = iter;
        iter++;
        counter++;
    }

    // if 0 pts
    if(prev_iter == _pts.end() && iter == _pts.end())
    {
        return start_x_coord + DELTA;
    }
    else if(iter == _pts.end() && prev_iter != _pts.end())
    {
        // not enough pts after start_x_coord
        return iter->xCoord;
    }
    else if(prev_iter != _pts.end() && iter != _pts.end())
    {
        // still pts after the num_points pts have been traversed
        return iter->xCoord;
    }
    else // prev_i doesn't exist but iter does exist
    {
        // shouldn't happen!
    }
    
    cout << "***getEndXCoord returning 180, shouldn't have ever happened!" << endl;
    return 180.0;
  }

 private:
	multiset<GeoPoint> _pts;
    bool _is_db;
    int _id;
    char* _db_hostname;
    int _db_port;
};

int main(int argc, char **argv) {
  int port = 4321;
  bool is_db = false;
  int id = -1;
  int db_port = 6666;
  char* c_db_hostname = NULL;

  if(argc > 2)
  {
    string s_is_db(argv[1]);
    if(s_is_db.compare("1") == 0)
    {
        is_db = true;
    }
    else if(s_is_db.compare("0") != 0)
    {
        cout << "Unrecognized input for is_db" << endl;
    }

    if(argc > 3 && argc == 6) 
    {
        char* c_port = argv[2];
        port = atoi(c_port);
        
        if(is_db == false)
        {
            //only backups need ids
            char* c_id = argv[3];
            id = atoi(c_id);

            //only backups need database info

            c_db_hostname = argv[4];
            
            //only backups need database port info
            char* c_db_port = argv[5];
            db_port = atoi(c_db_port);
        }
    }
    else
    {
        cout << "Usage: < 0 | 1> <port> <db hostname> <db port>" << endl;
    }
  }

  shared_ptr<MockDBHandler> handler;
  if(is_db)
  {
    handler = shared_ptr<MockDBHandler>(new MockDBHandler());
  }
  else
  {
    handler = shared_ptr<MockDBHandler>(new MockDBHandler(id, c_db_hostname, db_port)); 
  }
  shared_ptr<TProcessor> processor(new MockDBProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

