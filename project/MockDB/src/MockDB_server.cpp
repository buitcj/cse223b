// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MockDB.h"
#include "GeoPoint.h"
#include <stdlib.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::MockDBServer;

using namespace std;

class MockDBHandler : virtual public MockDBIf {
 public:
  MockDBHandler() {
    // Your initialization goes here
    _is_db = true;

    _id = -1;
    _db_hostname = NULL;
    _db_port = -1;
  }

  MockDBHandler(int id, char* db_hostname, int db_port)
  {
    _id = id;
    _db_hostname = db_hostname;
    _db_port = db_port;

    _is_db = false;
  }

  void init()
  {
    _lx = -9999;
    _rx = 9999;
  }

  void GetPointsInRegion(GetPointsResponse& _return, const ThriftGeoPoint& ll, const ThriftGeoPoint& ur) {
    printf("GetPointsInRegion\n");
    GeoPoint lower_pt(ll.xCoord, -90.0);
    multiset<GeoPoint>::iterator lower_iter = _pts.lower_bound(lower_pt);
    if(lower_iter != _pts.end())
    {
        while(lower_iter != _pts.end() && lower_iter->xCoord <= ur.xCoord)
        {
            if(lower_iter->yCoord >= ll.yCoord &&
               lower_iter->yCoord <= ur.yCoord)
            {
                ThriftGeoPoint gpt;
                gpt.xCoord = lower_iter->xCoord;
                gpt.yCoord = lower_iter->yCoord;
                _return.pts.push_back(gpt);
            }
            lower_iter++;
        }
        _return.status = ServerStatus::OK;
    }
    else
    {
        _return.status = ServerStatus::OK;
        _return.pts.clear();
    }
  }

  ServerStatus::type AddPoint(const ThriftGeoPoint& p) {
    cout << "AddPoint called: (" << p.xCoord << "," << p.yCoord << ")" << endl;
    GeoPoint pt(p.xCoord, p.yCoord);
    _pts.insert(pt);

    if(_is_db == false)
    {
        // connect to the db and add the pt 
        string s_db_hostname(_db_hostname);

        boost::shared_ptr<TSocket> socket(new TSocket(s_db_hostname, _db_port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        MockDBClient mock_client(protocol);
        // Making the RPC Call
        transport->open();
        ServerStatus::type status = mock_client.AddPoint(p);
        transport->close();

        return status;
    }

    return ServerStatus::OK;
  }

  double GetEndXCoordinate(const double start_x_coord, const int32_t num_points) {
    const double DELTA = 0.0000003;
    printf("GetEndXCoordinate\n");
    multiset<GeoPoint>::iterator iter;
    GeoPoint pt(start_x_coord, -90.0);
    iter = _pts.find(pt);
    multiset<GeoPoint>::iterator prev_iter;
    int counter = 0;
    while(iter != _pts.end() && counter < num_points)
    {
        prev_iter = iter;
        iter++;
        counter++;
    }

    // if 0 pts
    if(prev_iter == _pts.end() && iter == _pts.end())
    {
        return start_x_coord + DELTA;
    }
    else if(iter == _pts.end() && prev_iter != _pts.end())
    {
        // not enough pts after start_x_coord
        return iter->xCoord;
    }
    else if(prev_iter != _pts.end() && iter != _pts.end())
    {
        // still pts after the num_points pts have been traversed
        return iter->xCoord;
    }
    else // prev_i doesn't exist but iter does exist
    {
        // shouldn't happen!
    }
    
    cout << "***getEndXCoord returning 180, shouldn't have ever happened!" << endl;
    return 180.0;
  }

  void SetRange(const double start_x_coord, const double end_x_coord) {
    if(_is_db == false)
    {
        printf("SetRange\n");
        string s_db_hostname(_db_hostname);

        boost::shared_ptr<TSocket> socket(new TSocket(s_db_hostname, _db_port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        MockDBClient mock_client(protocol);
        // Making the RPC Call

//GetPointsInRegion(GetPointsResponse& _return, const ThriftGeoPoint& ll, const ThriftGeoPoint& ur)
        GetPointsResponse pts;

        ThriftGeoPoint ll;
        ll.xCoord = -180.0;
        ll.yCoord = -90.0;

        ThriftGeoPoint ur;
        ur.xCoord = 180.0;
        ur.yCoord = 90.0;

        transport->open();
        mock_client.GetPointsInRegion(pts, ll, ur);
        transport->close();

        if(pts.status != ServerStatus::FAILED)
        {
            _pts.clear();
            for(unsigned int i = 0; i < pts.pts.size(); i++)
            {
                // add all the vector points to the class map
                GeoPoint gp;
                gp.xCoord = pts.pts[i].xCoord;
                gp.yCoord = pts.pts[i].yCoord;
                _pts.insert(gp);
            }
        }
    }
  }


 private:
    double _lx;
    double _rx;
	multiset<GeoPoint> _pts;
    bool _is_db;
    int _id;
    char* _db_hostname;
    int _db_port;
};

int main(int argc, char **argv) {
  int port = -1;
  bool is_db = false;
  int id = -1;
  int db_port = 6666;
  char* c_db_hostname = NULL;
  
  cout << "Usage: <myport> < 0 | 1> <id> <db hostname> <db port>" << endl;

  if(argc == 1) 
  {
    return 0;
  }

  if(argc > 2)
  {
    char* c_port = argv[1];
    port = atoi(c_port);

    string s_is_db(argv[2]);
    if(s_is_db.compare("1") == 0)
    {
        is_db = true;
    }
    else if(s_is_db.compare("0") != 0)
    {
        cout << "Unrecognized input for is_db" << endl;
        return 1;
    }

    if(argc > 4 && argc == 6 && is_db == false) 
    {
        //only backups need ids
        char* c_id = argv[3];
        id = atoi(c_id);

        //only backups need database info

        c_db_hostname = argv[4];
        
        //only backups need database port info
        char* c_db_port = argv[5];
        db_port = atoi(c_db_port);
    }
  }

  if(is_db)
  {
    cout << "DB server starting with port: " << port << endl;
  }
  else
  {
    cout << "Backup server starting with port: " << port << " id: " <<
        id << " db name: " << c_db_hostname << " db port: " << db_port << endl;
  }

  shared_ptr<MockDBHandler> handler;
  if(is_db)
  {
    handler = shared_ptr<MockDBHandler>(new MockDBHandler());
  }
  else
  {
    handler = shared_ptr<MockDBHandler>(new MockDBHandler(id, c_db_hostname, db_port)); 
  }
  shared_ptr<TProcessor> processor(new MockDBProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

